# Transaction (DBMS를 사용하는 가장 큰 이유 중 하나)
- 작업의 최소 단위  
- 작업의 범위를 임의로 설정 -> Transaction으로 지정한다.  
ex) 3000원 이체 A -> B 이러한 과정을 Transaction으로 지정한다.  
①. A 계좌의 존재여부 확인 select   
②. B 계좌의 존재여부 확인 select  
③. A의 잔액을 select  
④. A의 잔액을 update  
⑤. B의 잔액을 select  
⑥. B의 잔액을 update  

- ACID
1. Atomicity(원자성)  
"all or nothing"  
모든 연산이 완전하게 적용되거나 아무것도 적용되지 않음을 보장하는 특성이다.  
ex) 은행에서 A가 B에게 송금을 하는 과정에서 오류가 발생하였을때 원자성이 보장되어 송금 자체가 취소된다면 혼란을 방지할 수 있다.
2. Consistancy(일관성)  
일관성은 데이터베이스의 트랜잭션이 제약조건, cascades, triggers를 포함한 정의된 모든 조건에 맞게 데이터의 값이 변경됨을 의미한다. 프로그래머가 의도한 연산들에 대해 사전에 정의한 조건과 맞지 않는 데이터의 변경으로 인해 오류가 발생하지 않음을 보장해주는 것이다. 일관성을 보장해주지 못해 데이터를 제약조건에 맞지 않는 데이터가 입력된다면 외래키가 기본키를 참조하는 과정에서 참조 오류가 생길 수도 있고, 제한된 조건을 넘는 데이터를 의도적으로 입력하여 메모리를 덮어쓰는 버퍼 오버플로우 공격에 취약하는 등 오류와 공격에 취약해질 것이다.  
ex) 데이터 베이스에 CUD 연산을 진행하였을 때 스키마와 제약조건과 같이 사전에 설정한 룰에 맞지 않는 데이터가 들어가는 것을 방지해줄 수 있다.
3. Isolation(독립성)  
"동기화 개념"  
트랜잭션의 독립성은 DBMS에서 데이터의 무결성을 결정하는 특성이다. DBMS에서 다수의 유저들이 같은 시간에 같은 데이터에 접근하였을 때 수행중인 트랜잭션이 완료될 때 까지 다른 트랜잭션의 요청을 막음으로써 업데이트가 누락되는 등, 데이터가 꼬이는 것을 방지해줄 수 있는 것이다. 이 독립성이 없다면 복수의 사용자에 의해 dirty reads이나 lost updates이 발생할 것이다. 독립성은 Isolation Level으로 설정될 수 있는데, 레벨이 높다면 이러한 동시 작업에 대한 독립성이 높아지지만 시스템 자원이 많이 필요할 것이다. 반대로 레벨이 낮다면 독립성이 낮아지지만 시스템 자원이 반대로 적게 필요할 것이다.
4. Durablity(영속성)  
"데이터에 저장"  
지속성은 커밋된 연산이 영구적으로 지속됨을 보장하는 속성이다. 즉, 시스템 문제 등으로 인해 오류가 발생하더라도 구행된 트랜잭션이 영원히 반영되어야 한다는 것이다. 지속성은 로그를 이용하여 구현되는데, 커밋의 성능을 위해 지속성이 일부분 포기 되는 방식도 존재한다.

- Transaction 설정 실습  
Use sqldb;  
START TRANSACTION;  
SELECT *  
FROM usertbl;  
DELETE   
FROM usertbl;  
rollback;  
SELECT *  
FROM usertbl;  
-- COMMIT(작업한 SQL구문을 정말로 적용), ROLLBACK(Transaction으로 설정된 작업을 무시)  
   -- 여기까지 트랜젝션을 설정한다.

# SQL 분류
## 1. DML(Data Manipulation Language)
select, insert, update, delete  
## 2. DDL(Data Definition Language)
create, drop, alter
## 3. DCL(Data Control Language)
(보안관련) grant, deny 
